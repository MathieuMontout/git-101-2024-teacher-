---
title: "Dplyr 101"
author: "Fabrice Rossi"
format: 
  html:
    code-fold: true
---

```{r}
#| message: false
here::i_am("git-101-2024.Rproj")
library(here)
library(vroom)
library(ggplot2)
theme_set(theme_bw())
```

## Data import

```{r}
#| message: false
white_wine <- vroom(here("data", "winequality-white.csv"))
```

|                        |                      |
|------------------------|----------------------|
| Number of observations | `r NROW(white_wine)` |
| Number of variables    | `r NCOL(white_wine)` |

```{r}
ggplot(white_wine, aes(x = quality)) +
  geom_bar()
```

## Data transformation
```{r}
#| message: false
library(dplyr)
```

### Column extraction 
```{r}
class(white_wine)
## class + column extraction
class(white_wine$quality)
## column extraction and then class
white_wine$quality |> class()
white_wine[["quality"]] |> class()
white_wine$`fixed acidity` |> class()
white_wine[["fixed acidity"]] |> class()
## dplyr style
white_wine |>
  pull(quality) |>
  class()
class(pull(white_wine, quality))
```

With `dplyr`, `pull()` is the column extraction function, somewhat similar to the
dollar `$` operator and to the double bracket `[[]]`. 


### Column recoding
This ggplot call gives a warning because `quality` is numeric which is not
supported for bar filling in `geom_bar()`.

```{r}
#| eval: false
#| code-fold: false
ggplot(white_wine, aes(x = quality, fill = quality)) +
  geom_bar()
```


```{r}
#| eval: false
white_wine$quality <- factor(white_wine$quality,
  ordered = TRUE,
  levels = 3:9
) ## 3:9 means 3, 4, 5, ..., 9
white_wine$quality <- white_wine$quality |> factor(
  ordered = TRUE,
  levels = 3:9
) ## 3:9 means 3, 4, 5, ..., 9
```

```{r}
white_wine <- white_wine |>
  mutate(quality = factor(quality, ordered = TRUE, levels = 3:9))
```

```{r}
ggplot(white_wine, aes(x = quality, fill = quality)) +
  geom_bar()
```

### Computing new columns
This is again a task for `mutate()`.

```{r}
white_wine <- white_wine |>
  mutate(`captured sulfur dioxide` = `total sulfur dioxide` - `free sulfur dioxide`,
         `free sd %` = round(`free sulfur dioxide` / `total sulfur dioxide` * 100, 2))
```

## Sub-setting
### Selecting columns
Column sub-setting is done with the `select()` function.

```{r}
white_wine |> 
  select(`fixed acidity`, `volatile acidity`, `citric acid`, pH)
```

Side note: we can display nicely data frames with the `knitr::kable()` function
but the original data frame is too big, so we select the first 10 rows with
`slice()`. 

```{r}
#| message: false
white_wine |> 
  select(`fixed acidity`, `volatile acidity`, `citric acid`, pH) |>
  slice(1:10) |>
  knitr::kable()
```
Positional selection based on the indices of the columns.

```{r}
#| eval: false
white_wine |> 
  select(1:3)
```

Columns can also be selected based on conditions on their names or on their
nature. 

```{r}
#| eval: false
white_wine |> 
  select(contains("acid") | pH)
```

Selection based on the content.

```{r}
#| eval: false
white_wine |> 
  select(where(is.factor))
```

```{r}
#| eval: false
white_wine |> 
  select(where(\(x) is.numeric(x) & (max(x) < 5)))
#we can either use select on the names (direct) or select on the properties of the columns (without considering the name).
#here we will keep only numerical column where the max of the column is less than 5.
```

### Selecting rows

Simple selection is based on indices with `slice()`. 

```{r}
white_wine |> 
  slice(1:5, 150:155) |>
  select(alcohol, quality) |>
  knitr::kable()

#two way to select rows, slice and filter, slice operate on the number of rows, filter 
```

Condition based selection uses `filter()`.

```{r}
white_wine |> 
  filter(alcohol > 14) |>
  select(alcohol, quality, `citric acid`, `residual sugar`) |>
  knitr::kable()
```
### Simple application
```{r}
ggplot(white_wine, aes(x=alcohol)) +
  geom_density(bw="sj") +
  geom_rug(alpha = 0.1)
```
```{r}
white_wine |> 
  filter(alcohol >= 13, `citric acid` < 1) |>
  ggplot(aes(x=`citric acid`, y=`residual sugar`, color = alcohol)) +
  geom_point(alpha=0.75) +
  scale_color_viridis_c()
```

```{r}
white_wine |> 
  filter(alcohol <= 9) |>
  ggplot(aes(x=`citric acid`, y=`residual sugar`, color = alcohol)) +
  geom_point(alpha=0.75) +
  scale_color_viridis_c()
```
```{r}
white_wine |>
  mutate(`alcohol category` = case_when(alcohol <= 9 ~ "low",
                                        alcohol >= 13 ~ "high",
                                        .default = "medium")) |>
  filter(`alcohol category` != "medium") |>
  filter(`citric acid` <= 1) |> 
  ggplot(aes(x=`citric acid`, y=`residual sugar`, color = alcohol)) +
  geom_point(alpha=0.75) +
  scale_color_viridis_c() +
  facet_wrap(vars(`alcohol category`))
```


15/10/24

## Aggregation functions
aka summary functions : turn a possibly long vector into a single.
take as an input a vector and produces/output a vector with a single value.

-standard statistics: 'max()', 'min()', 'median()', etc.
-logical operations: 'any()' and 'all()'
-counts and ranks: 'n()'

### Simple summary use
Based on the 'summarise()'
```{r}
white_wine |>
  summarise(
    med_alcohol = median(alcohol),
    sd(alcohol)
  )
```

```{r}
white_wine |>
  select(alcohol) |>
  mutate(m_a = median(alcohol))
```

```{r}
white_wine |>
  select(alcohol) |>
  mutate(a_m_a = alcohol - median(alcohol),
         .keep = "none")
```

```{r}
white_wine |>
  select(alcohol) |>
  mutate(na = (alcohol - mean(alcohol))/sd(alcohol),
         na_r = (alcohol- median(alcohol))/IQR(alcohol),
         .keep = "none")
```


```{r}
white_wine |>
  summarise(
  sd(alcohol),
  median(alcohol))
#the alcohol value is over dispersed when we compare it to a normal gaussian.
```

### More complex summary functions
Essentially 'quantiale()'

```{r}
quantile(white_wine$`residual sugar`)
#we have a vector with min value (0% = O,6), the max and median.
#Robust statistics = stat that is hard to manipulate, like the median, even if we add an extreme value it won't modify substantially the median.
```
```{r}
quantile(white_wine$`residual sugar`, probs = seq(0, 1, 0.1))

```

With summarize we can only specify one value whereas quantile is useful when we have more than one value.

```{r}
white_wine |>
  summarise(quantile(`residual sugar`))

```

```{r}
#official solution
white_wine |>
  reframe(quantile(`residual sugar`),
          mean(`residual sugar`))
```


```{r}
#We can also use this solution
sugar_stats <- white_wine |>
  summarise(list(quantile(`residual sugar`)),
            mean(`residual sugar`))

```


### Group by
####introduction
```{r}
white_wine|> 
  summarise(median(`residual sugar`),
            n(), #will give us the number of value that have been used to compute the median.
            .by = quality ) |> 
  arrange(quality) #we use that to order the quality from the lowest to the highest.

#summarise split dataset into as many subset as they are quality value, it compute for each of the substet the median.
```

```{r}
white_wine|> 
  summarise(median(`residual sugar`),
            n(), #will give us the number of value that have been used to compute the median.
            .by = alcohol ) |> 
  arrange(alcohol) 

#summarise split dataset into as many subset as they are quality value, it compute for each of the substet the median.
```


#quantizing numerical variable
```{r}
#we group over two things alcohol and residual sugar
white_wine|>
  mutate(ha = alcohol >= 13) |>
  summarise(median(`residual sugar`),
            n(), 
            .by = ha)
```

```{r}
#cut() slice numerical value into (...) based on intervals
#the lowest value has to be less than the average
#cut is always producing factors (discrete variable)
white_wine|>
  mutate(alcohol_class = cut(alcohol, breaks = c(7,9,10,12,13,15), ordered_result = TRUE) ) |>
  summarise(median(`residual sugar`),
            n(), 
            .by = alcohol_class)
```

# 22/10/24



```{r}
white_wine|>
  mutate(alcohol_class = cut(alcohol, breaks = c(7,9,10,12,13,15), ordered_result = TRUE) ) |>
  ggplot(aes(x = alcohol_class)) +
  geom_bar()
#the  fact of having small classes can blur the result that we are going to have in the following examples.
```

```{r}
ggplot(white_wine, aes(x=alcohol, y = quality))+
  geom_boxplot()
#shows the conditional distribution of alcohol given quality (alcohol is conitnuous so we can't look for the invesrse)
```

```{r}
white_wine|>
  mutate(alcohol_class = cut(alcohol, breaks = c(7,9,10,12,13,15), ordered_result = TRUE) ) |>
  ggplot(aes(x = alcohol_class, fill = quality)) +
  geom_bar()
#conditional distribution of quality given the alcohol class. the quality nine seems to have a high value of alcohol in the first graph (above) and we see the quality nine in the class [12,13].

#when we want to study the effect of a variable on another one we have to create classes to see what is happening (except if the other variable is continuous).
```


to have different classes we can use the function quantile()




```{r}
alcohol_quantile <-
  white_wine |> 
  pull(alcohol) |>
  quantile(probs = seq (0, 1, by = 0.2)) #in the case that we want 5 intervals.
alcohol_quantile

```


```{r}
#way to modify the content of a vector/ list :
alcohol_quantile[1] <- alcohol_quantile[1] - 1 #we do that because otherwise some value won't be taken by the lower bound
alcohol_quantile
```

```{r}
white_wine|>
  mutate(alcohol_class = cut(alcohol, breaks = alcohol_quantile, ordered_result = TRUE) ) |>
  ggplot(aes(x = alcohol_class)) +
  geom_bar()
#not perfect because there are equalities in the quantiles.
```

```{r}
white_wine|>
  mutate(alcohol_class = cut(alcohol, breaks = alcohol_quantile, ordered_result = TRUE) ) |>
  ggplot(aes(x = alcohol_class, fill = quality)) +
  geom_bar(position = "fill")
#we can see a quality effect.
```



```{r}
alcohol_quantile_2 <-
  white_wine |> 
  pull(alcohol) |>
  quantile(probs = seq (0, 1, by = 0.1)) #in the case that we want 5 intervals.
alcohol_quantile_2

```


```{r}
#way to modify the content of a vector/ list :
alcohol_quantile_2[1] <- alcohol_quantile_2[1] - 1 #we do that because otherwise some value won't be taken by the lower bound
alcohol_quantile_2
```
```{r}
white_wine|>
  mutate(alcohol_class = cut(alcohol, breaks = alcohol_quantile_2, ordered_result = TRUE) ) |>
  ggplot(aes(x = alcohol_class, fill = quality)) +
  geom_bar(position = "fill")
#we can see a quality effect.
```
